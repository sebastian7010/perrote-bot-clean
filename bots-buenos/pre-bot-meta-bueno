// @ts-nocheck
// ================== Boot & safety ==================
process.on('uncaughtException', (e) => console.error('[uncaughtException]', (e && e.stack) || e));
process.on('unhandledRejection', (e) => console.error('[unhandledRejection]', (e && e.stack) || e));

// ================== Setup bÃ¡sico ==================
require('dotenv').config();
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const express = require('express');
const twilio = require('twilio');
const OpenAI = require('openai');
const IORedis = require('ioredis');
const nodemailer = require('nodemailer');
const axios = require('axios');
const FormData = require('form-data');

const app = express();

// Meta (Cloud API) manda JSON:
app.use(express.json());

// Twilio envÃ­a x-www-form-urlencoded:
app.use(express.urlencoded({ extended: false }));




// ===== META CLOUD API =====
const META_WA_TOKEN = process.env.META_WA_TOKEN || '';
const META_PHONE_NUMBER_ID = process.env.META_PHONE_NUMBER_ID || '';
const META_VERIFY_TOKEN = process.env.META_VERIFY_TOKEN || 'sebastian123';


// ================== Config ==================
const PORT = process.env.PORT || 3008;
const TIMEZONE = process.env.TIMEZONE || 'America/Bogota';

const OPENAI_MODEL = process.env.OPENAI_MODEL || 'gpt-4o-mini';
const OPENAI_TIMEOUT_MS = parseInt(process.env.OPENAI_TIMEOUT_MS || '6000', 10);
const OPENAI_MAX_ATTEMPTS = parseInt(process.env.OPENAI_MAX_ATTEMPTS || '1', 10);
const OPENAI_MAX_TOKENS = parseInt(process.env.OPENAI_MAX_TOKENS || '1200', 10);

const MAX_USER_CHARS = parseInt(process.env.MAX_USER_CHARS || '2000', 10);
const HISTORY_MAX_TURNS = parseInt(process.env.HISTORY_MAX_TURNS || '6', 10);
const UNLIMITED_INPUT = String(process.env.UNLIMITED_INPUT || '1') === '1';

const WHATSAPP_ACK = String(process.env.WHATSAPP_ACK || '0') === '1'; // 0 = TwiML
const TWIML_EMAIL_COPY = String(process.env.TWIML_EMAIL_COPY || '0') === '1';

const COMPANY_NAME = process.env.COMPANY_NAME || 'Perrote y Gatote';
const BOT_NAME = process.env.BOT_NAME || 'Juan';
const SALES_EMAIL = process.env.SALES_EMAIL || process.env.FROM_EMAIL || 'ventas@tolentinosftw.com';

const DEBUG = String(process.env.DEBUG || '1') === '1';
const EMAIL_ON = String(process.env.DISABLE_EMAIL || '0') !== '1';

// Limpieza agresiva al detectar un nuevo carrito (para no arrastrar datos)
// 1 = borra shipping + estado pago al ver un carrito nuevo
const CLEAR_ON_NEW_CART = String(process.env.CLEAR_ON_NEW_CART || '1') === '1';

// ================== SDKs ==================
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const twilioClient = twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN);

// ================== Redis ==================
const redis = new IORedis(process.env.REDIS_URL || 'redis://127.0.0.1:6379');
const TTL_SECONDS = (parseInt(process.env.MEMORY_TTL_DAYS, 10) || 30) * 24 * 60 * 60;

// Idempotencia y lock
const IDEMP_TTL = 2 * 24 * 3600; // 48h
const LOCK_TTL = 3; // 3s lock por mensaje (evita carreras/silencios)

// ================== Mailer ==================
const mailer = nodemailer.createTransport({
    host: process.env.SMTP_HOST,
    port: Number(process.env.SMTP_PORT || 587),
    secure: String(process.env.SMTP_SECURE || 'false') === 'true',
    auth: process.env.SMTP_USER && process.env.SMTP_PASS ? { user: process.env.SMTP_USER, pass: process.env.SMTP_PASS } : undefined,
});

// ===== Helpers =====
const emsg = (e) => (e && e.message) ? e.message : String(e);
const sha1 = (s) => crypto.createHash('sha1').update(String(s)).digest('hex');

function withTimeout(promise, ms) {
    let t;
    return Promise.race([
        promise,
        new Promise((_, reject) => { t = setTimeout(() => reject(new Error('TIMEOUT')), ms); }),
    ]).finally(() => clearTimeout(t));
}

// â€” COP: convierte "35.000" o "40,400" a 35000 / 40400
function parseCOPnum(v) {
    if (v == null) return null;
    const digits = String(v).replace(/[^\d]/g, '');
    const n = Number(digits);
    return Number.isFinite(n) ? n : null;
}

function formatCOP(n) {
    try { return '$' + Number(n).toLocaleString('es-CO'); } catch { return '$' + n; }
}

// EnvÃ­o de email (wrapper seguro)
async function sendEmail({ to, subject, text, html, attachments }) {
    try {
        if (!EMAIL_ON) return;
        if (!to) to = process.env.ADMIN_EMAIL;
        if (!to) return;
        const info = await mailer.sendMail({
            from: process.env.FROM_EMAIL || SALES_EMAIL,
            to,
            subject: subject || '(sin asunto)',
            text: text || undefined,
            html: html || undefined,
            attachments: attachments || undefined,
        });
        if (DEBUG) console.log('[MAIL] sent:', info.messageId);
    } catch (e) {
        console.error('[MAIL] error:', emsg(e));
    }
}

// Telegram: enviar fotos
async function sendTelegramPhotos(paths = [], caption = '') {
    try {
        const token = process.env.TELEGRAM_BOT_TOKEN;
        const chatId = process.env.TELEGRAM_CHAT_ID;
        if (!token || !chatId) return false;
        for (let i = 0; i < paths.length; i++) {
            const fd = new FormData();
            fd.append('chat_id', chatId);
            if (i === 0 && caption) fd.append('caption', caption);
            fd.append('photo', fs.createReadStream(paths[i]));
            await axios.post(`https://api.telegram.org/bot${token}/sendPhoto`, fd, {
                headers: fd.getHeaders(),
                timeout: 20000,
            });
        }
        return true;
    } catch (e) {
        console.error('[TG] sendPhoto error:', e && e.message ? e.message : e);
        return false;
    }
}

// ================== CatÃ¡logo (JSON local) ==================
const CATALOG_PATH = path.join(__dirname, 'data', 'products.json');
let CATALOG = [];

function loadCatalog() {
    try {
        CATALOG = JSON.parse(fs.readFileSync(CATALOG_PATH, 'utf8'));
        if (DEBUG) console.log('[CATALOG] items:', CATALOG.length);
    } catch (e) {
        console.error('[CATALOG] error:', e.message);
        CATALOG = [];
    }
}
loadCatalog();

function coalesce() {
    for (let i = 0; i < arguments.length; i++) {
        const v = arguments[i];
        if (v !== undefined && v !== null && v !== '') return v;
    }
    return null;
}

function getName(p) { return coalesce(p.name, p.Nombre, p.title, p.productName, p.nombre, p.titulo) || ''; }

function getId(p) { return coalesce(p.id, p._id, p.sku, p.code, p.codigo, p.slug) || ''; }

function getPriceRaw(p) { return coalesce(p.price, p.precio, p.unit_price, p.unitPrice, p.valor, p.cost, p.costo); }

function searchCatalog(q) {
    q = (q || '').toLowerCase();
    return CATALOG.filter(p => {
        const txt = [getName(p), p.brand || p.marca || '', p.category || p.categoria || '', (p.tags || []).join(' ')].join(' ').toLowerCase();
        return txt.includes(q);
    }).slice(0, 10);
}

// ================== Parseo de carrito web ==================
function parseWebCart(text) {
    const out = { items: [], totalFromText: null };
    if (!text) return out;
    const blockRe = /\*([^*]+)\*\s*Cantidad:\s*(\d+)\s*Precio\s*unitario\s*:\s*([\$\d\.\,]+)\s*Subtotal\s*:\s*([\$\d\.\,]+)/gim;
    let m;
    while ((m = blockRe.exec(text)) !== null) {
        const name = m[1].trim();
        const qty = parseInt(m[2], 10);
        const unit = parseCOPnum(m[3]);
        const subtotal = parseCOPnum(m[4]);
        if (!name || !Number.isFinite(qty) || !Number.isFinite(unit)) continue;
        out.items.push({ name, qty, unit, subtotal: Number.isFinite(subtotal) ? subtotal : qty * unit });
    }
    const totalMatch = text.match(/Total\s*a\s*pagar\s*:\s*([\$\d\.\,]+)/i);
    if (totalMatch) out.totalFromText = parseCOPnum(totalMatch[1]);
    return out;
}

function looksLikeWebCart(text) {
    if (!text) return false;
    const a = /\*\s*[^*]+\s*\*\s*Cantidad:\s*\d+/i.test(text);
    const b = /Precio\s*unitario\s*:\s*[\$\d\.\,]+/i.test(text);
    const c = /Subtotal\s*:\s*[\$\d\.\,]+/i.test(text);
    const d = /Total\s*a\s*pagar\s*:\s*[\$\d\.\,]+/i.test(text);
    return (a && b && c) || d;
}

// ================== EnvÃ­os (reglas locales) ==================
function normalize(t) { return (t || '').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, ''); }

function inferCity(linesJoined) {
    const t = normalize(linesJoined);
    if (/\brionegro\b/.test(t)) return 'rionegro';
    if (/\b(llano\s*grande|llanogrande)\b/.test(t)) return 'llanogrande';
    if (/\bmarinilla\b/.test(t)) return 'marinilla';
    if (/\b(la\s*ceja|ceja)\b/.test(t)) return 'laceja';
    if (/\bcarmen\b/.test(t) && /\bviboral\b/.test(t)) return 'carmenviboral';
    if (/\bmedellin\b/.test(t)) return 'medellin';
    if (/\benvigado\b/.test(t)) return 'envigado';
    if (/\bsabaneta\b/.test(t)) return 'sabaneta';
    if (/\bbello\b/.test(t)) return 'bello';
    if (/\bitag[uÃ¼]i\b/.test(t)) return 'itagui';
    return null;
}

function shippingForCity(cityKey) {
    if (!cityKey) return { allowed: null, price: null, note: 'ConfÃ­rmame ciudad para calcular envÃ­o. Por ahora solo Antioquia.' };
    if (['rionegro', 'llanogrande', 'marinilla', 'laceja', 'carmenviboral'].includes(cityKey))
        return { allowed: true, price: 12500, note: 'EnvÃ­o local 12.500.' };
    if (['medellin', 'envigado', 'sabaneta', 'bello', 'itagui'].includes(cityKey))
        return { allowed: true, price: 15000, note: 'EnvÃ­o Ãrea MDE 15.000.' };
    return { allowed: false, price: null, note: 'Por ahora solo despachamos en Antioquia.' };
}

// ====== Helpers de envÃ­o (completitud y faltantes) ======
const REQUIRED_SHIPPING_FIELDS = ['name', 'phone', 'address', 'city']; // barrio/hora opcionales
function isShippingComplete(lead) {
    if (!lead) return false;
    return REQUIRED_SHIPPING_FIELDS.every(k => {
        const v = lead[k];
        return v !== undefined && v !== null && String(v).trim() !== '';
    });
}

function missingShippingFields(lead) {
    const L = lead || {};
    const map = {
        name: 'Nombre completo',
        phone: 'Celular',
        address: 'DirecciÃ³n + Apto/Casa',
        city: 'Ciudad',
    };
    return REQUIRED_SHIPPING_FIELDS
        .filter(k => !L[k] || String(L[k]).trim() === '')
        .map(k => map[k]);
}

// ====== Pago reciente (evita arrastre de pruebas antiguas) ======
function isPaidRecent(lead, hours = 6) {
    if (!lead) return false;
    const proofs = Array.isArray(lead.paymentProofs) ? lead.paymentProofs : [];
    if (!proofs.length) return false;
    const ts = Number(lead.paymentReceivedAt || 0);
    if (!ts) return false;
    return (Date.now() - ts) < hours * 3600 * 1000;
}

// ================== Prompt del bot ==================
const systemPrompt = `
Eres ${BOT_NAME}, asesor de ventas de "${COMPANY_NAME}". Siempre en espaÃ±ol, cÃ¡lido y concreto.

Objetivo: cerrar la compra sin fricciÃ³n.

Reglas:
- Si el usuario envÃ­a un carrito (lista con "Cantidad / Precio unitario / Subtotal"), responde con:
  1) Resumen de Ã­tems y total,
  2) MÃ©todos de pago (Nequi / Davivienda / BRE-B),
  3) Solicita datos de envÃ­o (Nombre, Celular, DirecciÃ³n + Apto/Casa, Barrio, Ciudad, Referencia opcional, Horario 8â€“15).
- Si ya tengo datos de envÃ­o suficientes, NO pidas otra vez direcciÃ³n/productos: SOLO solicita foto del comprobante.
- Si llega la foto del comprobante, confirma pago y hora de entrega:
   â€¢ Si el cliente dio hora: "Haremos lo posible por las HH:00; los envÃ­os salen entre 8â€“15."
   â€¢ Si no dio hora: "Lo despachamos hoy en la ventana 8â€“15."
- Ciudades: Rionegro/La Ceja/Carmen/Llanogrande/Marinilla $12.500; MedellÃ­n/Envigado/Sabaneta/Bello/ItagÃ¼Ã­ $15.000; otros: por ahora solo Antioquia.
- No pidas cÃ©dula/NIT.
- MantÃ©n 4â€“8 lÃ­neas mÃ¡x. y evita tono robÃ³tico.
`.trim();

// ================== Parseo y contexto ==================
const CITIES = [
    'rionegro', 'la ceja', 'carmen de viboral', 'carmen del viboral',
    'llanogrande', 'marinilla', 'medellin', 'envigado', 'sabaneta', 'bello', 'itagÃ¼Ã­', 'itagui'
];

function norm(s) { return (s || '').trim().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, ''); }

function onlyDigits(s) { return (s || '').replace(/[^\d]/g, ''); }

function capWords(s) { return (s || '').split(/\s+/).map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' '); }

// ===== DIRECCIONES â€” heurÃ­stica reforzada =====
function isLikelyName(s) {
    const t = (s || '').trim();
    if (!t) return false;
    if (/\d|#/.test(t)) return false;
    const words = t.split(/\s+/);
    if (words.length < 2) return false;
    if (words.some(w => w.length < 2)) return false;
    return true;
}

// Palabras/abreviaciones comunes de vÃ­a
const STREET_TOKENS = '(?:carrera|cra|kr|kra|k|cr|calle|cll|cl|avenida|av|ak|autopista|tv|transv|transversal|dg|diagonal|mz|manzana|km|vereda|via)';

// Patrones numÃ©ricos tipo â€œ123 # 45-67â€, â€œNo 23-10â€, â€œNÂ° 12-34â€
const HOUSE_NUM_PAT =
    '(?:n(?:o|ro|Â°)\\.?\\s*\\d+(?:\\s*-\\s*\\d+)?)' + // No/Nro/NÂ° 123-45
    '|(?:\\d{1,3}[a-z]?\\s*(?:#|-)\\s*\\d{1,3}(?:\\s*-\\s*\\d{1,3})?)'; // 123 # 45-67 / 12-34

function isLikelyAddress(s) {
    const t = norm(s);
    if (!t) return false;
    // Evita falsos positivos con telÃ©fonos largos al inicio
    if (/^\d{6,}/.test(t)) return false;

    const hasStreetToken = new RegExp('\\b' + STREET_TOKENS + '\\b').test(t);
    const hasHouseNum = new RegExp('\\b(?:' + HOUSE_NUM_PAT + ')\\b').test(t);
    const hasHash = t.includes('#');

    // SeÃ±ales fuertes de direcciÃ³n
    if (hasStreetToken && (hasHouseNum || hasHash)) return true;

    // TambiÃ©n aceptar formatos mÃ­nimos: â€œcl 45 # 23-10â€, â€œcra 50  # 34-12â€
    if (hasHouseNum) return true;

    // Como Ãºltimo recurso, combo de nÃºmeros + separadores tÃ­picos
    if (/\d/.test(t) && /[#-]/.test(t) && hasStreetToken) return true;

    return false;
}

function isLikelyNeighborhood(s) {
    const t = (s || '').trim();
    if (!t) return false;
    if (/\#|\d{2,}/.test(t)) return false;
    if (t.length < 3 || t.length > 60) return false;
    return true;
}

function findCityFreeform(lines) {
    const joined = ' ' + lines.join(' ') + ' ';
    const t = norm(joined);
    const inf = inferCity(joined);
    if (inf) {
        const map = { rionegro: 'Rionegro', laceja: 'La Ceja', carmenviboral: 'Carmen de Viboral', llanogrande: 'Llanogrande', marinilla: 'Marinilla', medellin: 'MedellÃ­n', envigado: 'Envigado', sabaneta: 'Sabaneta', bello: 'Bello', itagui: 'ItagÃ¼Ã­' };
        return map[inf];
    }
    for (const c of CITIES) {
        if (t.includes(' ' + norm(c) + ' ')) return capWords(c);
    }
    return undefined;
}

function parseHourFreeform(text) {
    const m1 = text.match(/\b(\d{1,2})\s*[:\.]\s*(\d{2})\b/i);
    if (m1) { let h = parseInt(m1[1], 10); if (h >= 0 && h <= 23) return h; }
    const m2 = text.match(/\b(\d{1,2})\s*(am|pm)\b/i);
    if (m2) { let h = parseInt(m2[1], 10); const suf = m2[2].toLowerCase(); if (suf === 'pm' && h < 12) h += 12; if (h >= 0 && h <= 23) return h; }
    return undefined;
}

function extractAddressFromLine(ln) {
    const t = (ln || '').trim();
    if (!t) return '';

    // Buscar 3 variantes:
    // 1) Con token de vÃ­a + el resto hasta separador
    // 2) Formato No/Nro/NÂ° 12-34
    // 3) Formato 123 # 45-67 (o con '-')
    const addrRe = new RegExp(
        '(' +
        // 1) token de vÃ­a
        '\\b' + STREET_TOKENS + '\\b\\.?\\s*[^,;\\n]{0,80}' +
        '|' +
        // 2) No/Nro/NÂ°
        '\\b(?:' + HOUSE_NUM_PAT + ')\\b[^,;\\n]{0,40}' +
        ')',
        'i'
    );

    const m = t.match(addrRe);
    if (!m) {
        return isLikelyAddress(t) ? t : '';
    }

    let out = m[0].trim();

    // Evitar falsos positivos si empieza con â€œmuchos dÃ­gitosâ€ (telÃ©fonos)
    if (/^\d{6,}/.test(out)) return '';

    // Limpiezas: horas, telÃ©fonos, emails
    out = out.replace(/\b\d{1,2}\s*(am|pm)\b/ig, '').trim();
    out = out.replace(/(?:\+57\s*)?3[\s-]?\d(?:[\s-]?\d){8}\b/g, '').trim();
    out = out.replace(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/ig, '').trim();

    // Normalizar espacios alrededor de â€œ#â€ y â€œ-â€
    out = out.replace(/\s*#\s*/g, ' # ').replace(/\s*-\s*/g, '-').replace(/\s{2,}/g, ' ').trim();

    return out;
}

// Parser principal (no sobreescribe con basura)
function parseContactAndShipping(text, prevLead = {}) {
    const out = {};
    if (!text) return out;

    const rawLines = String(text).split(/\r?\n/).map(s => s.trim()).filter(Boolean);

    // TelÃ©fono CO (10 dÃ­gitos iniciando 3), tolera +57
    const phoneMatch = text.match(/(?:\+57\s*)?(3[\s-]?\d(?:[\s-]?\d){8})\b/);
    if (phoneMatch) {
        const digits = onlyDigits(phoneMatch[0]);
        out.phone = digits.length === 12 && digits.startsWith('57') ? digits.slice(2) : digits;
    }

    // Email
    const emailMatch = text.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/i);
    if (emailMatch) out.email = emailMatch[0];

    // Nombre declarado
    const nameDecl = text.match(/\b(me llamo|mi nombre es)\s+([a-zÃ¡Ã©Ã­Ã³ÃºÃ± ]{2,60})/i);
    if (nameDecl) out.name = capWords(nameDecl[2].trim());

    // Ciudad
    const city = findCityFreeform(rawLines);
    if (city) out.city = city;

    // Hora
    const h = parseHourFreeform(text);
    if (typeof h === 'number') out.preferredHour = h;

    // DirecciÃ³n (etiqueta o heurÃ­stica)
    let addressIdx = -1;
    for (let i = 0; i < rawLines.length; i++) {
        const ln = rawLines[i];

        const mDir = ln.match(/\b(direcci[oÃ³]n|dir)\s*[:\-]?\s*(.+)$/i);
        if (mDir) {
            const cand = extractAddressFromLine(mDir[2]);
            if (cand) {
                out.address = cand;
                addressIdx = i;
                break;
            }
        }

        // Si la lÃ­nea parece direcciÃ³n, intentalo
        if (isLikelyAddress(ln)) {
            const cand = extractAddressFromLine(ln);
            if (cand) {
                out.address = cand;
                addressIdx = i;
                break;
            }
        }
    }

    // Barrio
    for (let i = 0; i < rawLines.length; i++) {
        const ln = rawLines[i];
        const mBar = ln.match(/\b(barrio)\s*[:\-]?\s*(.+)$/i);
        if (mBar) {
            const cand = mBar[2].trim();
            if (isLikelyNeighborhood(cand)) { out.neighborhood = capWords(cand); break; }
        }
    }
    if (!out.neighborhood && addressIdx !== -1) {
        const candidates = [];
        if (rawLines[addressIdx - 1]) candidates.push(rawLines[addressIdx - 1]);
        if (rawLines[addressIdx + 1]) candidates.push(rawLines[addressIdx + 1]);
        for (const c0 of candidates) {
            const cand = (c0 || '').trim();
            if (!cand) continue;
            if (isLikelyNeighborhood(cand)) {
                const candNorm = norm(cand);
                const nameNorm = norm(out.name || prevLead.name || '');
                const cityNorm = norm(out.city || prevLead.city || '');
                if (candNorm && candNorm !== nameNorm && candNorm !== cityNorm) {
                    out.neighborhood = capWords(cand);
                    break;
                }
            }
        }
    }

    // Nombre por heurÃ­stica si no vino explÃ­cito
    if (!out.name) {
        for (const ln of rawLines) {
            const lnNorm = norm(ln);
            if (/\d/.test(ln)) continue;
            if (ln.length > 60) continue;
            if (isLikelyName(ln)) {
                const clashCity = norm(out.city || '') === lnNorm;
                const looksAddr = isLikelyAddress(ln);
                if (!clashCity && !looksAddr) {
                    if (out.neighborhood && norm(out.neighborhood) === lnNorm) continue;
                    out.name = capWords(ln);
                    break;
                }
            }
        }
    }

    // Barrio nunca igual a nombre
    if (out.neighborhood && out.name && norm(out.neighborhood) === norm(out.name)) {
        delete out.neighborhood;
    }

    return out;
}

function clampInput(text) {
    if (!text) return { text: '', notice: '' };
    if (UNLIMITED_INPUT) return { text, notice: '' };
    if (text.length <= MAX_USER_CHARS) return { text, notice: '' };
    const lines = text.split(/\r?\n/);
    const kept = [];
    for (let i = 0; i < lines.length; i++) {
        const ln = String(lines[i]);
        if (/^\s*(-|\d+[\).\s])/.test(ln)) kept.push(ln.trim());
        if (kept.join('\n').length > MAX_USER_CHARS) break;
    }
    let final = kept.join('\n');
    if (!final) final = text.slice(0, MAX_USER_CHARS);
    const notice = 'âœ‚ï¸ Tu mensaje era muy largo; lo resumÃ­ para responder Ã¡gilmente.\n\n';
    return { text: final, notice };
}

function pickRecentHistory(hist) {
    if (!Array.isArray(hist)) return [];
    const trimmed = hist.slice(-HISTORY_MAX_TURNS * 2);
    let out = [],
        total = 0,
        BUDGET = 8000;
    for (let i = trimmed.length - 1; i >= 0; i--) {
        const m = trimmed[i];
        const len = m && m.content ? m.content.length : 0;
        if (total + len > BUDGET) break;
        out.unshift(m);
        total += len;
    }
    return out;
}

// ====== FALLBACK contextual (cuando falle OpenAI)
function buildFallbackReply(lead) {
    const paid = isPaidRecent(lead);
    const miss = missingShippingFields(lead);

    if (!paid && isShippingComplete(lead)) {
        const resumen =
            (lead.name ? `â€¢ Nombre: ${lead.name}\n` : '') +
            (lead.phone ? `â€¢ Celular: ${lead.phone}\n` : '') +
            (lead.address ? `â€¢ DirecciÃ³n: ${lead.address}\n` : '') +
            (lead.apartment ? `â€¢ Apto/Casa: ${lead.apartment}\n` : '') +
            (lead.neighborhood ? `â€¢ Barrio: ${lead.neighborhood}\n` : '') +
            (lead.city ? `â€¢ Ciudad: ${lead.city}\n` : '') +
            (lead.reference ? `â€¢ Referencia: ${lead.reference}\n` : '') +
            (lead.preferredHour != null ? `â€¢ Horario preferido: ${String(lead.preferredHour).padStart(2, '0')}:00\n` : '');

        return (
            (resumen ? `Â¡Perfecto! TomÃ© estos *datos de envÃ­o*:\n${resumen}\n` : '') +
            `Para programar el despacho, por favor envÃ­ame la *foto del comprobante de pago*.\n\n` +
            `MÃ©todos:\n- *Nequi:* ${process.env.PAY_NEQUI || 'CHANGE_ME'}\n- *Davivienda:* ${process.env.PAY_DAVIVIENDA || 'CHANGE_ME'}\n- *BRE-B:* ${process.env.PAY_BREB || process.env.PAY_PSE || 'CHANGE_ME'}`
        );
    }

    if (!isShippingComplete(lead)) {
        const faltan = miss.map(f => `â€¢ *${f}*`).join('\n');
        return `Â¡Gracias! Para despachar, confÃ­rmame por favor:\n${faltan}\n` +
            `\n(Puedes enviarlos en varios mensajes, voy registrando todo).`;
    }

    return 'Listo. Â¿Deseas que lo despachemos hoy? Si es asÃ­, puedo recibir el comprobante de pago cuando lo tengas.';
}

// ================== OpenAI (timeout + reintentos) ==================
async function askOpenAI(messages, opts) {
    opts = opts || {};
    const model = opts.model || OPENAI_MODEL;
    const maxTokens = opts.maxTokens || OPENAI_MAX_TOKENS;
    const temperature = typeof opts.temperature === 'number' ? opts.temperature : 0.4;

    for (let attempt = 1; attempt <= OPENAI_MAX_ATTEMPTS; attempt++) {
        try {
            if (DEBUG) console.log('[AI] intento', attempt, '| msgs=', messages.length);
            const resp = await withTimeout(
                openai.chat.completions.create({ model, messages, temperature, max_tokens: maxTokens }),
                OPENAI_TIMEOUT_MS
            );
            const ok = resp && resp.choices && resp.choices[0] && resp.choices[0].message && resp.choices[0].message.content;
            if (ok) {
                const text = String(resp.choices[0].message.content).trim();
                if (DEBUG) console.log('[AI] OK len=', text.length);
                return text;
            }
            throw new Error('Respuesta vacÃ­a de OpenAI');
        } catch (e) {
            console.error('[AI] error intento', attempt, ':', emsg(e));
            if (attempt === OPENAI_MAX_ATTEMPTS) throw e;
            await new Promise(r => setTimeout(r, 400 * attempt));
        }
    }
}

// ===== Twilio media from request =====
function getMediaUrlsFromRequest(req) {
    const out = [];
    const num = Number((req && req.body && req.body.NumMedia) ? req.body.NumMedia : 0);
    for (let i = 0; i < num; i++) {
        const url = (req && req.body) ? req.body['MediaUrl' + i] : null;
        const ctype = (req && req.body) ? req.body['MediaContentType' + i] : null;
        if (url) out.push({ url: String(url), contentType: String(ctype || '') });
    }
    return out;
}

// ===== Archivo resumen pedido =====
function writeOrderFile({ wa, finalReply, body, lead, media }) {
    try {
        const dir = path.join(__dirname, 'orders');
        if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
        const ts = new Date().toISOString().replace(/[:.]/g, '-');
        const file = path.join(dir, `${ts}__${(wa || '').replace(/[^+\d]/g, '')}.md`);
        const lines = [];
        lines.push(
            `# Pedido de ${wa || '-'} (${ts})`,
            ``,
            `## Resumen generado para el cliente`,
            finalReply || '(vacÃ­o)',
            ``,
            '## Mensaje original del cliente',
            body || '(vacÃ­o)',
            ``,
            '## Datos de envÃ­o (si disponibles)',
            '- Nombre: ' + ((lead && lead.name) || '-'),
            '- Celular: ' + ((lead && lead.phone) || '-'),
            '- DirecciÃ³n: ' + ((lead && lead.address) || '-'),
            '- Apto/Casa: ' + ((lead && lead.apartment) || '-'),
            '- Barrio: ' + ((lead && lead.neighborhood) || '-'),
            '- Ciudad: ' + ((lead && lead.city) || '-'),
            '- Referencia (opcional): ' + ((lead && lead.reference) || '-'),
            '- Horario preferido: ' + ((lead && lead.preferredHour != null) ? (String(lead.preferredHour).padStart(2, '0') + ':00') : '-'),
            ``,
            '## Comprobantes (imÃ¡genes enviadas)'
        );
        if (media && media.length) media.forEach((m, i) => lines.push(`- #${i + 1}: ${m.url} (${m.contentType || 'image'})`));
        else lines.push('(sin adjuntos)');
        fs.writeFileSync(file, lines.join('\n'), 'utf8');
        return file;
    } catch (e) { console.error('[FILE] writeOrderFile:', emsg(e)); return null; }
}

// === Enviar WhatsApp con (opcional) media â€” CON DEDUP ===
const DEDUP_TTL_SECONDS = 120;
async function sendWhatsAppOnce(to, body, mediaUrls = []) {
    try {
        if (!to || !body) return null;
        const payloadKey = `sent:${to}:${sha1(body)}`;
        const first = await redis.set(payloadKey, '1', 'NX', 'EX', DEDUP_TTL_SECONDS);
        if (first === null) {
            if (DEBUG) console.log('[WA] dedup: ya se enviÃ³ ese texto recientemente a', to);
            return null;
        }
        const payload = { from: process.env.TWILIO_WHATSAPP_FROM, to, body };
        if (Array.isArray(mediaUrls) && mediaUrls.length) payload.mediaUrl = mediaUrls.slice(0, 10);
        const msg = await twilioClient.messages.create(payload);
        if (DEBUG) console.log('[WA] sent', msg.sid, '->', to);
        return msg.sid;
    } catch (e) {
        console.error('[WA] error]:', emsg(e));
        return null;
    }
}


// === Enviar WhatsApp usando META CLOUD API ===
async function sendMetaText(to, body) {
    try {
        if (!META_WA_TOKEN || !META_PHONE_NUMBER_ID) {
            console.error('[META][SEND] Falta META_WA_TOKEN o META_PHONE_NUMBER_ID');
            return;
        }

        const url = `https://graph.facebook.com/v20.0/${META_PHONE_NUMBER_ID}/messages`;
        const payload = {
            messaging_product: 'whatsapp',
            to, // nÃºmero SIN +, ej: "57310XXXXXXX"
            text: { body }
        };

        const resp = await axios.post(url, payload, {
            headers: {
                Authorization: `Bearer ${META_WA_TOKEN}`,
                'Content-Type': 'application/json'
            },
            timeout: 20000,
        });

        if (DEBUG) console.log('[META][SEND] OK', JSON.stringify(resp.data));
    } catch (e) {
        console.error('[META][SEND] error:', emsg(e));
    }
}




// ================== Webhook Meta (WhatsApp Cloud API) ==================
const META_VERIFY_TOKEN = process.env.VERIFY_TOKEN || 'sebastian123';

// VerificaciÃ³n (GET) â€” Meta llama aquÃ­ cuando haces "Verify and save"
app.get('/webhook', (req, res) => {
    const mode = req.query['hub.mode'];
    const token = req.query['hub.verify_token'];
    const challenge = req.query['hub.challenge'];

    console.log('[META][GET]', { mode, token, challenge });

    if (mode === 'subscribe' && token === META_VERIFY_TOKEN) {
        console.log('[META] Webhook verification OK âœ…');
        return res.status(200).send(challenge);
    } else {
        console.log('[META] Webhook verification FAILED âŒ');
        return res.sendStatus(403);
    }
});

// RecepciÃ³n de mensajes (POST) â€” aquÃ­ llegan los mensajes reales de WhatsApp Cloud
app.post('/webhook', async(req, res) => {
    try {
        if (DEBUG) {
            console.log('[META][POST] body =', JSON.stringify(req.body, null, 2));
        }

        // Estructura tÃ­pica:
        // entry[0].changes[0].value.messages[0]
        const entry = req.body.entry && req.body.entry[0];
        const change = entry && entry.changes && entry.changes[0];
        const value = change && change.value;
        const messages = value && value.messages;

        // Puede que sea solo un evento de status, entonces no hay messages
        if (!messages || !messages.length) {
            return res.sendStatus(200);
        }

        const msg = messages[0];
        const from = msg.from; // nÃºmero del usuario (ej: "573108853158")
        const type = msg.type; // "text", "image", etc.

        let bodyText = '';
        let media = [];

        if (type === 'text') {
            bodyText = msg.text && msg.text.body ? String(msg.text.body) : '';
        } else if (type === 'image') {
            bodyText = '[imagen recibida]';
            // AquÃ­ podrÃ­as guardar msg.image.id si luego quieres descargarla
            media = [{ url: msg.image.id, contentType: 'image/jpeg' }];
        } else {
            bodyText = '[mensaje tipo ' + type + ' recibido]';
        }

        // Usamos un ID propio para separar Meta de Twilio en Redis
        const waId = 'meta:' + from;

        if (DEBUG) {
            console.log('IN META >>', waId, '|', bodyText.slice(0, 140), '... | media:', media.length);
        }

        const result = await processConversation(waId, bodyText, media);
        const finalReply = (result && result.finalReply) ?
            result.finalReply :
            'Â¡Gracias! Ya mismo te confirmo por aquÃ­.';

        // Enviar respuesta a travÃ©s de la API de Meta
        const url = `https://graph.facebook.com/v21.0/${process.env.WA_PHONE_NUMBER_ID}/messages`;

        await axios.post(
            url, {
                messaging_product: 'whatsapp',
                to: from,
                type: 'text',
                text: { body: finalReply },
            }, {
                headers: {
                    Authorization: `Bearer ${process.env.WA_ACCESS_TOKEN}`,
                    'Content-Type': 'application/json',
                },
                timeout: 15000,
            }
        );

        if (DEBUG) {
            console.log('OUT META << len =', finalReply.length);
        }

        // Siempre responder 200 rÃ¡pido para que Meta no reintente
        res.sendStatus(200);
    } catch (e) {
        console.error('[META] error en /webhook:', emsg(e));
        // Meta solo necesita 200, aunque internamente haya fallado algo
        res.sendStatus(200);
    }
});



app.post('/whatsapp', async(req, res) => {
    const MessagingResponse = twilio.twiml.MessagingResponse;
    const messageSid = String((req.body && (req.body.MessageSid || req.body.SmsSid)) || '');
    const from = (req && req.body && req.body.From) ? String(req.body.From) : '';
    const body = (req && req.body && req.body.Body) ? String(req.body.Body).trim() : '';
    const media = getMediaUrlsFromRequest(req);

    const fallbackId = messageSid || ('FAKE-' + sha1(from + '|' + body.slice(0, 64)));
    const seenKey = `seen:msg:${fallbackId}`;
    const lockKey = `lock:msg:${fallbackId}`;

    try {
        const firstTime = await redis.set(seenKey, '1', 'NX', 'EX', IDEMP_TTL);
        if (firstTime === null) {
            if (!WHATSAPP_ACK) { const tw = new MessagingResponse(); return res.type('text/xml').send(tw.toString()); } else return res.sendStatus(200);
        }

        const gotLock = await redis.set(lockKey, '1', 'NX', 'EX', LOCK_TTL);
        if (gotLock === null) {
            if (!WHATSAPP_ACK) { const tw = new MessagingResponse(); return res.type('text/xml').send(tw.toString()); } else return res.sendStatus(200);
        }

        if (DEBUG) console.log('IN >>', from, '|', body.slice(0, 140), '... | media:', media.length, '| sid=', fallbackId);

        const result = await processConversation(from, body, media);
        const out = (result && result.finalReply) ? result.finalReply : 'Â¡Gracias! Ya mismo te confirmo por aquÃ­.';

        if (!WHATSAPP_ACK) {
            if (TWIML_EMAIL_COPY && EMAIL_ON) {
                const emailKey = `sent:twimlcopy:${(process.env.ADMIN_EMAIL || '')}:${sha1(from + '|' + out)}`;
                const firstMail = await redis.set(emailKey, '1', 'NX', 'EX', 300);
                if (firstMail) await sendEmail({ to: process.env.ADMIN_EMAIL, subject: 'Copia de respuesta (TwiML) - ' + COMPANY_NAME, text: 'Destino: ' + from + '\n\n' + out });
            }
            const tw = new MessagingResponse();
            const msg = tw.message({ statusCallback: process.env.TWILIO_STATUS_CALLBACK || undefined });
            msg.body(out);
            if (DEBUG) console.log('OUT << TwiML len=', out.length);
            return res.type('text/xml').send(tw.toString());
        } else {
            await sendWhatsAppOnce(from, out);
            return res.sendStatus(200);
        }
    } catch (err) {
        console.error('Error /whatsapp:', emsg(err));
        try {
            if (!WHATSAPP_ACK) {
                const twimlErr = new MessagingResponse();
                twimlErr.message('Ups, hubo un problema. Intenta de nuevo en unos segundos ðŸ™');
                return res.type('text/xml').send(twimlErr.toString());
            } else return res.sendStatus(200);
        } catch (_e) { return res.sendStatus(200); }
    }
});

// ================== Core de conversaciÃ³n ==================
async function processConversation(userWa, rawBody, media = []) {
    const hist = await getHistory(userWa);
    let lead = await getLead(userWa);
    const trimmed = (rawBody || '').trim();

    // --- 0) Reset manual por keyword (opcional)
    if (/^\s*(reset|reiniciar|nuevo pedido)\s*$/i.test(trimmed)) {
        await saveLead(userWa, {}); // limpia todo
        await setHistory(userWa, []);
        return { finalReply: 'Â¡Listo! Empecemos de cero. EnvÃ­ame tu carrito o los productos, y luego los datos de envÃ­o.' };
    }

    // 1) Capturar/merge de datos (fragmentado o todo-en-uno)
    const parsed = parseContactAndShipping(rawBody, lead || {});
    const gotAny = Object.keys(parsed).length > 0 || (media && media.length);
    if (gotAny) {
        lead = await saveLead(userWa, {
            ...(lead || {}),
            ...parsed,
            paymentProofs: (lead && Array.isArray(lead.paymentProofs) ? lead.paymentProofs : []).concat(media || [])
        });
        // saneo barrio == nombre
        if (lead && lead.neighborhood && lead.name && norm(lead.neighborhood) === norm(lead.name)) {
            lead = await saveLead(userWa, {...lead, neighborhood: undefined });
        }
        if (DEBUG) console.log('[LEAD] actualizado:', lead);
    }

    // 2) Media = comprobante â‡’ marcar pago y confirmar
    if (media && media.length) {
        const downloaded = [];
        if (String(process.env.MEDIA_DOWNLOAD || '0') === '1') {
            const dir = path.join(__dirname, 'orders', 'media');
            for (const m of media) {
                const p = await downloadTwilioMedia(m.url, dir);
                if (p) downloaded.push(p);
            }
        }

        lead = await saveLead(userWa, {
            ...lead,
            paymentProofs: (lead.paymentProofs || []).concat(media || []),
            paymentReceivedAt: Date.now()
        });

        const hourTxt = (lead && lead.preferredHour != null) ?
            String(lead.preferredHour).padStart(2, '0') + ':00' :
            null;

        // Telegram (opcional)
        try {
            const token = process.env.TELEGRAM_BOT_TOKEN,
                chatId = process.env.TELEGRAM_CHAT_ID;
            const caption =
                `ðŸ§¾ Comprobante recibido de ${userWa}\n` +
                (lead && lead.name ? `Nombre: ${lead.name}\n` : '') +
                (lead && lead.phone ? `Cel: ${lead.phone}\n` : '') +
                (lead && lead.address ? `DirecciÃ³n: ${lead.address}\n` : '') +
                (lead && lead.city ? `Ciudad: ${lead.city}\n` : '') +
                (hourTxt ? `Horario: ${hourTxt}\n` : '');
            if (token && chatId) {
                if (downloaded.length) await sendTelegramPhotos(downloaded, caption);
                else await axios.post(`https://api.telegram.org/bot${token}/sendMessage`, { chat_id: chatId, text: caption }, { timeout: 20000 });
            }
        } catch (e) { console.error('[TG] error:', emsg(e)); }

        const llegada = hourTxt ?
            `Haremos lo posible para que llegue sobre las *${hourTxt}* (nuestros envÃ­os salen entre 8am y 3pm).` :
            `Lo despachamos hoy dentro de la ventana de *8am a 3pm*.`;

        const finalReply =
            `Â¡Gracias! RecibÃ­ el *comprobante de pago* âœ…\n` +
            `Tu orden fue programada para despacho. ${llegada}\n` +
            `Cualquier novedad te escribo por aquÃ­.`;

        hist.push({ role: 'user', content: rawBody || '[comprobante de pago]' });
        hist.push({ role: 'assistant', content: finalReply });
        await setHistory(userWa, hist);

        try { writeOrderFile({ wa: userWa, finalReply, body: rawBody, lead, media }); } catch {}
        return { finalReply };
    }

    // 3) Estado actual
    const paid = isPaidRecent(lead);
    let envioCompleto = isShippingComplete(lead);

    // 4) Carrito detectado
    const isCart = looksLikeWebCart(trimmed);
    if (isCart) {
        // **RESET en nuevo carrito**: evita â€œya tengo tus datosâ€ y pagos pegados
        if (CLEAR_ON_NEW_CART) {
            await saveLead(userWa, {}); // limpia completamente
            lead = {};
            envioCompleto = false;
        }

        const parsedCart = parseWebCart(trimmed);
        let total = 0;
        const lines = [];
        parsedCart.items.forEach((it, idx) => {
            const line = `${idx + 1}. *${it.name}* Â· Cantidad: ${it.qty} Â· ${formatCOP(it.unit)} = ${formatCOP(it.subtotal)}`;
            lines.push(line);
            total += (it.subtotal || (it.qty * it.unit));
        });
        if (parsedCart.totalFromText != null && Math.abs(parsedCart.totalFromText - total) < 2000) {
            total = parsedCart.totalFromText;
        }

        const cityKey = inferCity([trimmed, (lead && lead.city) || ''].join(' '));
        const shipInfo = shippingForCity(cityKey);
        let envioLinea = '';
        if (shipInfo.allowed === true && shipInfo.price != null) {
            envioLinea = `\n${(lines.length + 1)}. *EnvÃ­o*: ${formatCOP(shipInfo.price)} (${shipInfo.note})`;
        } else if (shipInfo.allowed === false) {
            envioLinea = `\n${(lines.length + 1)}. *EnvÃ­o*: ${shipInfo.note}`;
        }

        const header =
            `Gracias por tu pedido, aquÃ­ tienes el resumen:\n\n${lines.join('\n')}` +
            `${envioLinea}\n\n*Total a pagar:* ${formatCOP(total)}${shipInfo.price ? ' + envÃ­o' : ''}`;

        const pagos =
            `\nPuedes pagar por... envÃ­ame el comprobante (foto):\n` +
            `- *Nequi:* ${process.env.PAY_NEQUI || 'CHANGE_ME'}\n` +
            `- *Davivienda:* ${process.env.PAY_DAVIVIENDA || 'CHANGE_ME'}\n` +
            `- *BRE-B:* ${process.env.PAY_BREB || process.env.PAY_PSE || 'CHANGE_ME'}`;

        let finalReply = header + '\n' + pagos + '\n';

        if (!envioCompleto) {
            const faltan = missingShippingFields(lead).map(f => `â€¢ *${f}*`).join('\n');
            finalReply += `\nPara el despacho, confÃ­rmame por favor:\n${faltan}\n\n*Por favor responde todo en un solo mensaje.*\n`;
        } else {
            finalReply +=
                `\nÂ¡Perfecto! Ya tengo tus *datos de envÃ­o*.\n` +
                `Para programar el despacho, por favor envÃ­ame la *foto del comprobante de pago*.\n`;
        }

        hist.push({ role: 'user', content: rawBody });
        hist.push({ role: 'assistant', content: finalReply });
        await setHistory(userWa, hist);

        try { writeOrderFile({ wa: userWa, finalReply, body: rawBody, lead, media }); } catch {}
        try {
            const adminTo = process.env.ADMIN_WA;
            if (adminTo && adminTo !== userWa) await sendWhatsAppOnce(adminTo, `ðŸ§¾ *Nuevo pedido (carrito)*\nDe: ${userWa}\n\n${finalReply}`);
        } catch (e) { console.error('[WA->ADMIN] notify (cart):', emsg(e)); }

        return { finalReply };
    }

    // 5) Sin carrito: lÃ³gica determinista ANTES de IA
    if (!paid && envioCompleto) {
        const resumen =
            (lead.name ? `â€¢ Nombre: ${lead.name}\n` : '') +
            (lead.phone ? `â€¢ Celular: ${lead.phone}\n` : '') +
            (lead.address ? `â€¢ DirecciÃ³n: ${lead.address}\n` : '') +
            (lead.apartment ? `â€¢ Apto/Casa: ${lead.apartment}\n` : '') +
            (lead.neighborhood ? `â€¢ Barrio: ${lead.neighborhood}\n` : '') +
            (lead.city ? `â€¢ Ciudad: ${lead.city}\n` : '') +
            (lead.reference ? `â€¢ Referencia: ${lead.reference}\n` : '') +
            (lead.preferredHour != null ? `â€¢ Horario preferido: ${String(lead.preferredHour).padStart(2, '0')}:00\n` : '');

        const finalReply =
            `Â¡Perfecto! TomÃ© estos *datos de envÃ­o*:\n${resumen}\n` +
            `Para programar el despacho, por favor envÃ­ame la *foto del comprobante de pago*.\n\n` +
            `MÃ©todos:\n- *Nequi:* ${process.env.PAY_NEQUI || 'CHANGE_ME'}\n- *Davivienda:* ${process.env.PAY_DAVIVIENDA || 'CHANGE_ME'}\n- *BRE-B:* ${process.env.PAY_BREB || process.env.PAY_PSE || 'CHANGE_ME'}`;

        hist.push({ role: 'user', content: rawBody });
        hist.push({ role: 'assistant', content: finalReply });
        await setHistory(userWa, hist);
        try { writeOrderFile({ wa: userWa, finalReply, body: rawBody, lead, media }); } catch {}
        return { finalReply };
    }

    if (!envioCompleto) {
        const faltan = missingShippingFields(lead).map(f => `â€¢ *${f}*`).join('\n');
        const finalReply = `Â¡Gracias! Para despachar, confÃ­rmame por favor:\n${faltan}\n\n*Responde todo en un solo mensaje, por favor.*`;

        hist.push({ role: 'user', content: rawBody });
        hist.push({ role: 'assistant', content: finalReply });
        await setHistory(userWa, hist);
        try { writeOrderFile({ wa: userWa, finalReply, body: rawBody, lead, media }); } catch {}
        return { finalReply };
    }

    // 6) IA (casos libres). Si falla, fallback contextual.
    const clamp = clampInput(rawBody);
    const recentHist = pickRecentHistory(hist);
    const messages = [
        { role: 'system', content: `Si el usuario describe necesidad pero no manda carrito: haz 1â€“2 preguntas cortas y sugiere 1â€“3 productos del catÃ¡logo si aplica. MantÃ©n foco en cerrar: si faltan *datos de envÃ­o*, pÃ­delos; si ya hay datos, pide *solo comprobante*.` },
        { role: 'system', content: systemPrompt },
        ...recentHist,
        { role: 'user', content: clamp.text }
    ];

    let reply;
    try {
        reply = await askOpenAI(messages, { model: OPENAI_MODEL, maxTokens: OPENAI_MAX_TOKENS, temperature: 0.4 });
    } catch (_e) {
        if (DEBUG) console.log('[AI] fallo â†’ usando fallback contextual');
        reply = buildFallbackReply(lead);
    }

    const finalReply = (clamp.notice || '') + reply;
    hist.push({ role: 'user', content: rawBody });
    hist.push({ role: 'assistant', content: finalReply });
    await setHistory(userWa, hist);

    try { writeOrderFile({ wa: userWa, finalReply, body: rawBody, lead, media }); } catch {}
    try {
        const adminTo = process.env.ADMIN_WA;
        if (adminTo && adminTo !== userWa) await sendWhatsAppOnce(adminTo, `ðŸ§¾ *Nuevo mensaje*\nDe: ${userWa}\n\n${finalReply}`);
    } catch (e) { console.error('[WA->ADMIN] notify (free):', emsg(e)); }

    return { finalReply };
}

// ================== Health ==================
app.get('/health', async(req, res) => {
    try {
        const ping = await redis.ping();
        return res.json({ ok: true, time: new Date().toISOString(), redis: ping === 'PONG', ackMode: WHATSAPP_ACK ? 'ACK+REST' : 'TwiML', model: process.env.OPENAI_MODEL });
    } catch (e) {
        return res.status(500).json({ ok: false, error: emsg(e) });
    }
});

// ================== Inicio ==================
app.listen(PORT, () => {
    console.log('Server on http://localhost:' + PORT, '| TZ=', TIMEZONE, '| ACK=', WHATSAPP_ACK ? 'ON' : 'OFF', '| UnlimitedInput=', UNLIMITED_INPUT ? 'YES' : 'NO', '| ClearOnCart=', CLEAR_ON_NEW_CART ? 'YES' : 'NO');
});

// ================== Salida limpia ==================
process.on('SIGINT', async() => {
    try { await redis.quit(); } catch {}
    console.log('[EXIT] SIGINT');
    process.exit(0);
});
process.on('SIGTERM', async() => {
    try { await redis.quit(); } catch {}
    console.log('[EXIT] SIGTERM');
    process.exit(0);
});

// === Media download helper ===
async function downloadTwilioMedia(url, outDir) {
    try {
        if (!url) return null;
        if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });
        const fileName = Date.now() + '-' + path.basename(url.split('?')[0]);
        const outPath = path.join(outDir, fileName);
        const resp = await axios.get(url, {
            responseType: 'stream',
            auth: { username: process.env.TWILIO_ACCOUNT_SID, password: process.env.TWILIO_AUTH_TOKEN },
            timeout: 20000,
        });
        await new Promise((resolve, reject) => {
            const ws = fs.createWriteStream(outPath);
            resp.data.pipe(ws);
            ws.on('finish', resolve);
            ws.on('error', reject);
        });
        return outPath;
    } catch (e) {
        console.error('[MEDIA] download error:', e && e.message ? e.message : e);
        return null;
    }
}

// ================== Redis helpers ==================
const keyHistory = (waId) => `chat:wa:${waId}:history`;
const keyLead = (waId) => `lead:${waId}`;

async function getHistory(waId) {
    try {
        const raw = await redis.get(keyHistory(waId));
        return raw ? JSON.parse(raw) : [];
    } catch (e) {
        if (DEBUG) console.error('[REDIS] getHistory]:', emsg(e));
        return [];
    }
}
async function setHistory(waId, history) {
    try {
        const trimmed = history.slice(-40);
        await redis.set(keyHistory(waId), JSON.stringify(trimmed), 'EX', TTL_SECONDS);
    } catch (e) {
        if (DEBUG) console.error('[REDIS] setHistory:', emsg(e));
    }
}
async function getLead(waId) {
    try {
        const raw = await redis.get(keyLead(waId));
        return raw ? JSON.parse(raw) : {};
    } catch { return {}; }
}
async function saveLead(waId, data) {
    const prev = await getLead(waId);
    const current = Object.assign({}, prev, data);
    await redis.set(keyLead(waId), JSON.stringify(current), 'EX', 90 * 24 * 3600);
    return current;
}